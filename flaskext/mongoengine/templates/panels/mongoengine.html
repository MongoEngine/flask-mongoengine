<table>
	<thead>
		<tr>
		    <th>#</th>
			<th style="width:10px;">Millis</th>
			<th>Ts</th>
			<th>Type</th>
			<th>Collection</th>
			<th>Info</th>
			<th>Query</th>
			<th>Optimizations</th>
		</tr>
	</thead>
	<tbody>
		{% for query in queries %}
			<tr class="{{ loop.cycle('djDebugOdd', 'djDebugEven') }}" >
			    <td>{{ loop.index }}</td>
				<td style="{% if query.millis>=100 %}color:red;{% endif %}">{{ query.millis }}</td>
				<td>{{ query.ts }}</td>
				<td>{{ query.operation_type }}</td>
				<td>{{ query.collection }}</td>
				<td>{{ query.extra|safe }}</td>
				<td>{{ query.query }}</td>
				<td>{{ query.optimizations }}</td>
			</tr>
		{% endfor %}
	</tbody>
</table>

<a href="javascript:document.getElementById('ddt-mongodb-info').style.display='block';">More Information</a>

<div id="ddt-mongodb-info" style="display:none;">
    <h4>Query</h4>
    <table>
        <tbody>
            <tr>
                <td><b>ntoreturn</b></td>
                <td>Number of objects the client requested for return from a query.</td>
            </tr>
            <tr>
                <td><b>nscanned</b></td>
                <td>Number of objects scanned in executing the operation.</td>
            </tr>
            <tr>
                <td><b>reslen</b></td>
                <td>Query result length in bytes.</td>
            </tr>
            <tr>
                <td><b>nreturned</b></td>
                <td>Number of objects returned from query.</td>
            </tr>
        </tbody>
    </table>
    
    <br/>
    <h5>Optimizations</h5>
    <p><b>index</b> If nscanned is much higher than nreturned, the database is scanning many objects to find the target objects. Consider creating an index to improve this.</p>
    <p><b>select members</b> reslen A large number of bytes returned (hundreds of kilobytes or more) causes slow performance. Consider passing find() a second parameter of the member names you require.</p>
    <br/>
    <em> Note: There is a cost for each index you create. The index causes disk writes on each insert and some updates to the collection. If a rare query, it may be better to let the query be "slow" and not create an index. When a query is common relative to the number of saves to the collection, you will want to create the index.</em>

    <h4>Update</h4>
    <table>
        <tbody>
            <tr>
                <td><b>fastmod</b></td>
                <td>Indicates a fast modify operation. These operations are normally quite fast</td>
            </tr>
            <tr>
                <td><b>fastmodinsert</b></td>
                <td>Indicates a fast modify operation that performed an upsert.</td>
            </tr>
            <tr>
                <td><b>upsert</b></td>
                <td>Indicates on upsert performed.</td>
            </tr>
            <tr>
                <td><b>moved</b></td>
                <td>Indicates the update moved the object on disk (not updated in place). This is slower than an in place update, and normally occurs when an object grows.</td>
            </tr>
            <tr>
                <td><b>key updates</b></td>
                <td>How many index keys changed during the update. Key updates are a little bit expensive since the db needs to remove the old key and insert a new key into the b-tree index.</td>
            </tr>
        </tbody>
    </table>
    
    <br/>
    <h5>Optimizations</h5>
    <p><b>index</b> Examine the nscanned info field. If it is a very large value, the database is scanning a large number of objects to find the object to update. Consider creating an index if updates are a high-frequency operation.</p>
    <br/>
    
    <p>
        <ul>
            <li><a href="http://www.mongodb.org/display/DOCS/Database+Profiler">MongoDB Database Profiler documentation</a>
        </ul>
    </p>
</div>